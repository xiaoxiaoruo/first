<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>

    <script>
        // var person1 = {
        //     name:"zs",
        //     age:10,
        //     eat:function(){
        //         console.log("哈哈哈");
        //     }
        // }
        // person1.eat();
        // console.log( person1.name );
        // 类 具有相同属性和方法的对象的集合 属性构造函数中 方法写在原型下 首字母大写用于区分

        function Person(name, age) {// 构造函数
            this.name = name;
            this.age = age;
        }

        Person.prototype.play = function () {
            console.log(this.name + "HAHAHA");
        };

        // 实例化 具体对象
        var person1 = new Person("zs", 30);
        /*
            person1.name = "zs" 也可以 相对麻烦
        */
        console.log(person1);
        var person2 = new Person("lisi", 20);
        console.log(person2);

        person1.play();

        // prototype 原型 构造函数有一个prototype属性 
        // 属性指向原型对象 (原型对象下有一个constructor属性 指向构造函数) 声明在原型对象下的属性和方法可以被实例化对象所共享 

        // __proto__ 实例对象下的属性 指向的是构造函数下的原型对象

        /*
            原型链
            当从一个对象那里调取属性或方法时，如果该对象自身不存在这样的属性或方法，
            就会去自己关联的prototype对象那里寻找，如果prototype没有，
            就会去prototype关联的前辈prototype那里寻找，
            如果再没有则继续查找Prototype.Prototype引用的对象，
            依次类推，直到Prototype.….Prototype为undefined
            （Object的Prototype就是undefined）从而形成了所谓的“原型链”。
        */

    </script>

</body>

</html>